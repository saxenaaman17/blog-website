[{"title":"Promise.all v Promise.allSettled","categories":["programming","javascript"],"href":"/my-first-post","content":" Promiseall Promiseall takes an array of promises as input and it returns a single Promise And that single promise resolves when all the promises in the array have resolved or it rejects immediately upon any of the promises rejecting If all the promises in the array resolve successfully Promiseall resolves with an array containing the resolved values of each promise maintaining the order of the original array If any of the promises in the array rejects Promiseall immediately rejects with the reason of the first promise that rejects and further promise resolutions or rejections are ignored Use cases for Promiseall When you want to make multiple API requests for different data needed to render a dashboard You need all the data to be successfully fetched before rendering the complete dashboard PromiseallSettled PromiseallSettled also takes an an array of promises as input and returns a single Promise that settles neither resolves nor rejects when all the promises in the array have settled either resolved or rejected It returns an array of objects where each object is the result for each promise in the array This object has a status property that indicates whether the promise was fulfilled or rejected If promise was fulfilled this object will have a value property and if it was rejected object will contain reason property to tell us why it was rejected Use cases for PromiseallSettled When you want to Upload multiple files to a server in multiple api calls and needing information about each file upload status whether successful or failed It allows you to proceed with further actions or error handling based on individual upload outcomes PromiseallSettled Example const fetchDataFromSource url return new Promiseresolve reject Simulating fetching data with random success or failure with 70 chance of success const isSuccess Mathrandom if isSuccess resolveData from url else rejectnew ErrorFailed to fetch data from url Mathrandom 2000 Array of promises representing fetching data from different sources const promises fetchDataFromSourcehttpsapiexamplecomdata1 fetchDataFromSourcehttpsapiexamplecomdata2 fetchDataFromSourcehttpsapiexamplecomdata3 fetchDataFromSourcehttpsapiexamplecomdata4 PromiseallSettledpromises thenresults resultsforEachresult index if resultstatus fulfilled consolelogPromise index 1 was fulfilled with value resultvalue else consolelogPromise index 1 was rejected with reason resultreasonmessage catcherror consoleerrorError occurred error Note catch block in PromiseallSettled will not be executed because catch block is specifically designed to handle rejected promises but PromiseallSettled doesnt reject when a promise inside an array of promises fails It considers both fulfilled and rejected promises as settled and includes their results in the array it returns in then block Note Promiseall implementation is very identical to PromiseallSettled"},{"title":"var, let and const","categories":["programming","javascript"],"href":"/my-second-post","content":"First of all before going into the details of var let and const let us understand what are scopes in js Scopes in js can be defined as a set of variables objects and functions that you have access to inside a js program And scopes are of three types 1 Global scope Global scope refers to variables functions or objects that are accessible from anywhere in your code 2 Function scope Function scope refers to variables or functions that are accessible only within the function they are defined in 3 Block scope It was introduced in ES6 Block scope refers to variables declared using let or const that are accessible only within the block they are defined in generaly within curly braces var Variables declared with var are functionscoped var variables are hosited at the top of their scope which essentially means they can be accessed before they are declared var variables can be redeclared and reassigned Example function hello consolelogvarVariable accessible here because var variables are hoisted to the top of their function scope but will have undefined value because their assignments are not hoisted if true var varVariable Aman consolelogvarVariable we can access this variable outside curly braces because it has function scpoe not block scope var varVariable Aman Saxena can be reassigned and redeclare too consolelogvarVariable this statement will give an error because we are trying to access this variable outside its function where its declared hello let Variables declared with let are blockscoped which means they are only accessible within the nearest enclosing block let variables are not hoisted to the top of the block which means they exist in the temporal dead zone until the declaration is encountered let variables can be reassigned but not redeclared within the same block Example function hello if true consolelogletVariable this will give an error because let variables are not hoisted to the top of their scope let letVariable Aman letVariable Aman Saxena can be reassigned consolelogletVariable this will give an error because let variables can only be accessed inside their nearest hello const Variables declared with const are also blockscoped const variables are not hoisted to the top of the block which means they exist in the temporal dead zone until the declaration is encountered const variables can not be reassigned after they are initialized but the contents of a const object or array if its mutable can be modified Example function hello const name Aman name Aman Saxena This will throw an error reassignment is not allowed const myArray 1 2 3 myArray 1 2 3 When we try to reassign the entire array to a const variable it will throw an error myArraypush4 This is allowed modifies the array const myObject key value1 myObject key value2 When we try to reassign the entire object to a const variable it will throw an error myObjectkey new value This is allowed modifies the object consolelogmyObject myArray Accessible and mutable within the block hello "},{"title":"Redux Simplified: Basics of Redux","categories":["programming","react js"],"href":"/my-third-post","content":"Redux is a pattern and library for managing and updating application state using events called actions so that the state can only be updated in a predictable fashion Application state here means state which needs to be used across your entire application or many parts of your applicationso we can consider this state as global state for our application And to update the state in predictable fashion we dont directly modify the state Instead we can dispatch actions to let Redux know what changes need to be made An action is a plain JavaScript object that has a type field We can think of an action as an event that describes something that happened in the application type field should be a string and this action object can have other fields too for additional information to let redux know about what happened Example of an action object const addProductToCartAction type cartproductAdded payload butter Application state in Redux lives in an object called the store We can create this store by passing in a reducer and this store object has a method called getState that returns the current state value So the question arises what is a reducer A reducer is a function that receives the current state and an action object and decides how to update the state if necessary and returns the new state We must follow some rules in regards to reducer reducer should only calculate the new state based on state and action arguments reducer are not allowed to modify the existing state Instead we should make a copy of the existing state and make changes to the copied values and then return it we should avoid doing random calculations async tasks and side effects in reducer Example of a reducer const initialState value function cartReducerstate initialState action Check to see if the reducer cares about this action if actiontype cartproductAdded If so make a copy of state return state and update the copy with the new value value actionpayload otherwise return the existing state unchanged return state Example of a store import configureStore from reduxjstoolkit const store configureStore reducer cartReducer consolelogstoregetState The Redux store has a method called dispatch The only way to update the state is to call storedispatch and pass in an action object The store will run its reducer function and save the new state value inside and we can call getState to retrieve the updated value storedispatch type cartproductAdded consolelogstoregetState Now to access the application state stored in store object we mostly use Selectors Selectors are functions which can extract specific piece of information from store state value So in large applications this can help us in avoiding repeating logic if different parts of the app need to read the same data from state const selectCartValue state statevalue const currentCartValue selectCartValuestoregetState consolelogcurrentCartValue Note almost all the stuff here in this post can also be found on official redux js documentation on this link click here"}]